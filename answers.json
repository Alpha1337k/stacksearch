{"items":[{"tags":["java","spring","spring-mvc","annotations"],"answers":[{"owner":{"reputation":561547,"user_id":203907,"user_type":"registered","accept_rate":81,"profile_image":"https://i.stack.imgur.com/07ej2.jpg?s=256&g=1","display_name":"Bozho","link":"https://stackoverflow.com/users/203907/bozho"},"is_accepted":false,"score":447,"last_activity_date":1312201215,"last_edit_date":1312201215,"creation_date":1311671761,"answer_id":6827820,"question_id":6827752,"body":"<p>They are almost the same - all of them mean that the class is a Spring bean. <code>@Service</code>, <code>@Repository</code> and <code>@Controller</code> are specialized <code>@Component</code>s. You can choose to perform specific actions with them. For example:</p>\n\n<ul>\n<li><code>@Controller</code> beans are used by spring-mvc</li>\n<li><code>@Repository</code> beans are eligible for persistence exception translation</li>\n</ul>\n\n<p>Another thing is that you designate the components semantically to different layers.</p>\n\n<p>One thing that <code>@Component</code> offers is that you can annotate other annotations with it, and then use them the same way as <code>@Service</code>.</p>\n\n<p>For example recently I made:</p>\n\n<pre><code>@Component\n@Scope(\"prototype\")\npublic @interface ScheduledJob {..}\n</code></pre>\n\n<p>So all classes annotated with <code>@ScheduledJob</code> are spring beans and in addition to that are registered as quartz jobs. You just have to provide code that handles the specific annotation.</p>\n"},{"owner":{"reputation":78461,"user_id":445543,"user_type":"registered","accept_rate":85,"profile_image":"https://www.gravatar.com/avatar/f5a3631b359d5fa1451372810c10d65e?s=256&d=identicon&r=PG","display_name":"stivlo","link":"https://stackoverflow.com/users/445543/stivlo"},"is_accepted":false,"score":1657,"last_activity_date":1612416936,"last_edit_date":1612416936,"creation_date":1312194012,"answer_id":6897038,"question_id":6827752,"body":"<p>From <a href=\"https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-stereotype-annotations\" rel=\"noreferrer\">Spring Documentation</a>:</p>\n<blockquote>\n<p>The <code>@Repository</code> annotation is a marker for any class that fulfils the\nrole or stereotype of a repository (also known as Data Access Object\nor DAO). Among the uses of this marker is the automatic translation of\nexceptions, as described in <a href=\"https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/data-access.html#orm-exception-translation\" rel=\"noreferrer\">Exception Translation</a>.</p>\n<p>Spring provides further stereotype annotations: <code>@Component</code>, <code>@Service</code>,\nand <code>@Controller</code>. <code>@Component</code> is a generic stereotype for any\nSpring-managed component. <code>@Repository</code>, <code>@Service</code>, and <code>@Controller</code> are\nspecializations of <code>@Component</code> for more specific use cases (in the\npersistence, service, and presentation layers, respectively).\nTherefore, you can annotate your component classes with <code>@Component</code>,\nbut, by annotating them with <code>@Repository</code>, <code>@Service</code>, or <code>@Controller</code>\ninstead, your classes are more properly suited for processing by tools\nor associating with aspects.</p>\n<p>For example, these stereotype annotations\nmake ideal targets for pointcuts. <code>@Repository</code>, <code>@Service</code>, and\n<code>@Controller</code> can also carry additional semantics in future releases of\nthe Spring Framework. Thus, if you are choosing between using\n<code>@Component</code> or <code>@Service</code> for your service layer, <code>@Service</code> is clearly the\nbetter choice. Similarly, as stated earlier, <code>@Repository</code> is already\nsupported as a marker for automatic exception translation in your\npersistence layer.</p>\n</blockquote>\n<div class=\"s-table-container\">\n<table class=\"s-table\">\n<thead>\n<tr>\n<th>Annotation</th>\n<th>Meaning</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>@Component</code></td>\n<td>generic stereotype for any Spring-managed component</td>\n</tr>\n<tr>\n<td><code>@Repository</code></td>\n<td>stereotype for persistence layer</td>\n</tr>\n<tr>\n<td><code>@Service</code></td>\n<td>stereotype for service layer</td>\n</tr>\n<tr>\n<td><code>@Controller</code></td>\n<td>stereotype for presentation layer (spring-mvc)</td>\n</tr>\n</tbody>\n</table>\n</div>"},{"owner":{"reputation":507,"user_id":1794781,"user_type":"registered","profile_image":"https://www.gravatar.com/avatar/a4dcb1ff6dfc4cffe3b1f634ca7cacfa?s=256&d=identicon&r=PG","display_name":"Das","link":"https://stackoverflow.com/users/1794781/das"},"is_accepted":false,"score":49,"last_activity_date":1351873636,"last_edit_date":1351873636,"creation_date":1351872345,"answer_id":13198943,"question_id":6827752,"body":"<p>Use of <code>@Service</code> and <code>@Repository</code> annotations are important from database connection perspective.</p>\n\n<ol>\n<li>Use <code>@Service</code> for all your web service type of DB connections</li>\n<li>Use <code>@Repository</code> for all your stored proc DB connections</li>\n</ol>\n\n<p>If you do not use the proper annotations, you may face commit exceptions overridden by rollback transactions. You will see exceptions during stress load test that is related to roll back JDBC transactions.</p>\n"},{"owner":{"reputation":2302,"user_id":2334534,"user_type":"registered","accept_rate":50,"profile_image":"https://i.stack.imgur.com/jsorb.jpg?s=256&g=1","display_name":"Ajit Singh","link":"https://stackoverflow.com/users/2334534/ajit-singh"},"is_accepted":false,"score":78,"last_activity_date":1522031166,"last_edit_date":1522031166,"creation_date":1368622125,"answer_id":16565447,"question_id":6827752,"body":"<blockquote>\n  <p>Spring 2.5 introduces further stereotype annotations: @Component, @Service and @Controller. @Component serves as a generic stereotype for any Spring-managed component; whereas, @Repository, @Service, and @Controller serve as specializations of @Component for more specific use cases (e.g., in the persistence, service, and presentation layers, respectively). What this means is that you can annotate your component classes with @Component, but by annotating them with @Repository, @Service, or @Controller instead, your classes are more properly suited for processing by tools or associating with aspects. For example, these stereotype annotations make ideal targets for pointcuts. Of course, it is also possible that @Repository, @Service, and @Controller may carry additional semantics in future releases of the Spring Framework. Thus, if you are making a decision between using @Component or @Service for your service layer, @Service is clearly the better choice. Similarly, as stated above, @Repository is already supported as a marker for automatic exception translation in your persistence layer.</p>\n\n<pre><code>@Component – Indicates a auto scan component.\n@Repository – Indicates DAO component in the persistence layer.\n@Service – Indicates a Service component in the business layer.\n@Controller – Indicates a controller component in the presentation layer.\n</code></pre>\n</blockquote>\n\n<p>reference :- <a href=\"https://docs.spring.io/spring/docs/3.0.0.M3/reference/html/ch04s12.html\" rel=\"noreferrer\">Spring Documentation - Classpath scanning, managed components and writing configurations using Java </a>  </p>\n"},{"owner":{"reputation":494,"user_id":1009686,"user_type":"registered","accept_rate":0,"profile_image":"https://www.gravatar.com/avatar/6eb2435dc6f7767f0f5554298516db6b?s=256&d=identicon&r=PG","display_name":"Manjush","link":"https://stackoverflow.com/users/1009686/manjush"},"is_accepted":false,"score":19,"last_activity_date":1392056497,"creation_date":1392056497,"answer_id":21684996,"question_id":6827752,"body":"<p>Even if we interchange @Component or @Repository or @service</p>\n\n<p>It will behave the same , but one aspect is that they wont be able to catch some specific exception related to DAO instead of Repository if we use component or @ service</p>\n"},{"owner":{"reputation":6334,"user_id":3244185,"user_type":"registered","profile_image":"https://i.stack.imgur.com/ocJBK.jpg?s=256&g=1","display_name":"Harshal Patil","link":"https://stackoverflow.com/users/3244185/harshal-patil"},"is_accepted":false,"score":237,"last_activity_date":1523395723,"last_edit_date":1523395723,"creation_date":1395734401,"answer_id":22628498,"question_id":6827752,"body":"<p>In Spring <code>@Component</code>, <code>@Service</code>, <code>@Controller</code>, and <code>@Repository</code> are Stereotype annotations which are used for:</p>\n\n<p><code>@Controller:</code> where your <strong>request</strong> <strong>mapping from presentation page</strong> done i.e. Presentation layer won't go to any other file it goes directly to <code>@Controller</code> class and checks for requested path in <code>@RequestMapping</code> annotation which written before method calls if necessary.</p>\n\n<p><code>@Service</code>: All business logic is here i.e. Data related calculations and all.This annotation of business layer in which our user not directly call persistence method so it will call this method using this annotation. <strong>It will request @Repository as per user request</strong></p>\n\n<p><code>@Repository</code>: This is Persistence layer(Data Access Layer) of application which used to get data from the database. i.e. <strong>all the Database related operations are done by the repository.</strong></p>\n\n<p><code>@Component</code> - Annotate your other components (for example REST resource classes) with a component stereotype.</p>\n\n<blockquote>\n  <p>Indicates that an annotated class is a \"<a href=\"http://docs.spring.io/spring-framework/docs/2.5.x/api/org/springframework/stereotype/Component.html\" rel=\"noreferrer\">component</a>\". Such classes are\n  considered as candidates for auto-detection when using\n  annotation-based configuration and classpath scanning.</p>\n  \n  <p>Other class-level annotations may be considered as identifying a\n  component as well, typically a special kind of component: e.g. the\n  @Repository annotation or AspectJ's @Aspect annotation.</p>\n</blockquote>\n\n<p><a href=\"http://docs.spring.io/spring-framework/docs/2.5.x/api/org/springframework/stereotype/Component.html\" rel=\"noreferrer\"><img src=\"https://i.stack.imgur.com/nXfyV.jpg\" alt=\"enter image description here\"></a></p>\n"},{"owner":{"reputation":5865,"user_id":1984049,"user_type":"registered","accept_rate":74,"profile_image":"https://i.stack.imgur.com/ruHJK.jpg?s=256&g=1","display_name":"Oliver","link":"https://stackoverflow.com/users/1984049/oliver"},"is_accepted":false,"score":402,"last_activity_date":1589309333,"last_edit_date":1589309333,"creation_date":1400822142,"answer_id":23821409,"question_id":6827752,"body":"<p>@Component is equivalent to </p>\n\n<pre><code>&lt;bean&gt;\n</code></pre>\n\n<p><strong>@Service, @Controller, @Repository = {@Component + some more special functionality}</strong></p>\n\n<p>That mean Service, The Controller and Repository are functionally the same. </p>\n\n<p>The three annotations are used to separate <strong>\"Layers\"</strong> in your application, </p>\n\n<ul>\n<li>Controllers just do stuff like dispatching, forwarding, calling service methods etc.</li>\n<li>Service Hold business Logic, Calculations etc.</li>\n<li>Repository are the DAOs (Data Access Objects), they access the database directly.</li>\n</ul>\n\n<p>Now you may ask why separate them: (I assume you know AOP-Aspect Oriented Programming) </p>\n\n<p>Let's say you want to Monitors the Activity of the DAO Layer only. You will write an Aspect (A class) class that does some logging before and after every method of your DAO is invoked, you are able to do that using AOP as you have three distinct Layers and are not mixed.</p>\n\n<p>So you can do logging of DAO  \"around\", \"before\" or \"after\" the DAO methods. You could do that because you had a DAO in the first place. What you just achieved is <strong>Separation of concerns or tasks.</strong></p>\n\n<p>Imagine if there were only one annotation @Controller, then this component will have dispatching, business logic and accessing database all mixed, so dirty code!</p>\n\n<p><em>Above mentioned is one very common scenario, there are many more use cases of why to use three annotations.</em></p>\n"},{"owner":{"reputation":4519,"user_id":1245337,"user_type":"registered","accept_rate":100,"profile_image":"https://i.stack.imgur.com/rQev9.jpg?s=256&g=1","display_name":"atish shimpi","link":"https://stackoverflow.com/users/1245337/atish-shimpi"},"is_accepted":false,"score":29,"last_activity_date":1405682581,"creation_date":1405682581,"answer_id":24823877,"question_id":6827752,"body":"<p><strong>@Repository</strong> <strong>@Service</strong> and <strong>@Controller</strong> are serves as specialization of @Component for more specific use on that basis you can replace @Service to @Component but in this case you loose the specialization.</p>\n\n<pre><code>1. **@Repository**   - Automatic exception translation in your persistence layer.\n2. **@Service**      - It indicates that the annotated class is providing a business service to other layers within the application.\n</code></pre>\n"},{"owner":{"reputation":525,"user_id":3083363,"user_type":"registered","accept_rate":0,"profile_image":"https://i.stack.imgur.com/ZnQxw.jpg?s=256&g=1","display_name":"Anil Amane","link":"https://stackoverflow.com/users/3083363/anil-amane"},"is_accepted":false,"score":28,"last_activity_date":1491192386,"last_edit_date":1491192386,"creation_date":1429978768,"answer_id":29867697,"question_id":6827752,"body":"<p>all these annotations are type of stereo type type of annotation,the difference between these three annotations are </p>\n\n<blockquote>\n  <ul>\n  <li>If we add the @Component then it tells the role of class is a component class it means it is a class consisting some logic,but it\n  does not tell whether a class containing a specifically business or\n  persistence or controller logic so we don't use directly this\n  @Component annotation</li>\n  <li>If we add @Service annotation then it tells that a role of class consisting business logic</li>\n  <li>If we add @Repository on top of class then it tells that a class consisting persistence logic</li>\n  <li>Here @Component is a base annotation for @Service,@Repository and @Controller annotations</li>\n  </ul>\n</blockquote>\n\n<p>for example </p>\n\n<pre><code>package com.spring.anno;\n@Service\npublic class TestBean\n{\n    public void m1()\n    {\n       //business code\n    }\n}\n\npackage com.spring.anno;\n@Repository\npublic class TestBean\n{\n    public void update()\n    {\n       //persistence code\n    }\n}\n</code></pre>\n\n<ul>\n<li>whenever we adds the <code>@Service</code> or <code>@Repositroy</code> or <code>@Controller</code> annotation by default <code>@Component</code> annotation is going to existence on top of the class</li>\n</ul>\n"},{"owner":{"reputation":566,"user_id":5426099,"user_type":"registered","profile_image":"https://www.gravatar.com/avatar/7e5bdef46ce67ddf4577d16100151d12?s=256&d=identicon&r=PG&f=1","display_name":"tech.yenduri","link":"https://stackoverflow.com/users/5426099/tech-yenduri"},"is_accepted":false,"score":23,"last_activity_date":1576454956,"last_edit_date":1576454956,"creation_date":1448514633,"answer_id":33931001,"question_id":6827752,"body":"<p>There is no difference between <code>@Component</code>, <code>@Service</code>, <code>@Controller</code>, <code>@Repository</code>.\n<code>@Component</code> is the Generic annotation to represent the component of our MVC. But there will be several components as part of our MVC application like service layer components, persistence layer components and presentation layer components. So to differentiate them Spring people have given the other three annotations also.</p>\n\n<ul>\n<li>To represent persistence layer components: <code>@Repository</code></li>\n<li>To represent service layer components: <code>@Service</code></li>\n<li>To represent presentation layer components: <code>@Controller</code></li>\n<li>or else you can use <code>@Component</code> for all of them.</li>\n</ul>\n"},{"owner":{"reputation":311,"user_id":1392352,"user_type":"registered","profile_image":"https://i.stack.imgur.com/3QVFY.png?s=256&g=1","display_name":"hardeep thakur","link":"https://stackoverflow.com/users/1392352/hardeep-thakur"},"is_accepted":false,"score":26,"last_activity_date":1529180636,"last_edit_date":1529180636,"creation_date":1451797848,"answer_id":34573538,"question_id":6827752,"body":"<p>Spring provides four different types of auto component scan annotations, they are <code>@Component</code>, <code>@Service</code>, <code>@Repository</code> and <code>@Controller</code>. Technically, there is no difference between them, but every auto component scan annotation should be used for a special purpose and within the defined layer. </p>\n\n<p><code>@Component</code>: It is a basic auto component scan annotation, it indicates annotated class is an auto scan component.</p>\n\n<p><code>@Controller</code>: Annotated class indicates that it is a controller component, and mainly used at the presentation layer.</p>\n\n<p><code>@Service</code>: It indicates annotated class is a Service component in the business layer.</p>\n\n<p><code>@Repository</code>: You need to use this annotation within the persistence layer, this acts like database repository.</p>\n\n<p>One should choose a more specialised form of <code>@Component</code> while annotating their class as this annotation may contain specific behavior going forward.</p>\n"},{"owner":{"reputation":35375,"user_id":2648077,"user_type":"registered","accept_rate":80,"profile_image":"https://www.gravatar.com/avatar/fd10f51a1b9acf80448616c0a03cd261?s=256&d=identicon&r=PG&f=1","display_name":"Alireza Fattahi","link":"https://stackoverflow.com/users/2648077/alireza-fattahi"},"is_accepted":false,"score":21,"last_activity_date":1529179708,"last_edit_date":1529179708,"creation_date":1462335824,"answer_id":37018430,"question_id":6827752,"body":"<p>We can answer this according to java standard</p>\n\n<p>Referring to <code>JSR-330</code>, which is now supported by spring, you can only use <code>@Named</code> to define a bean (Somehow <code>@Named=@Component</code>). So according to this standard, there seems that there is no use to define stereotypes (like <code>@Repository</code>, <code>@Service</code>, <code>@Controller</code>) to categories beans. </p>\n\n<p>But spring user these different annotations in different for the specific use, for example: </p>\n\n<ol>\n<li>Help developers define a better category for the competent. This categorizing may become helpful in some cases. (For example when you are using <code>aspect-oriented</code>, these can be a good candidate for <code>pointcuts</code>)</li>\n<li><code>@Repository</code> annotation will add some functionality to your bean (some automatic exception translation to your bean persistence layer).</li>\n<li>If you are using spring MVC, the <code>@RequestMapping</code> can only be added to classes which are annotated by <code>@Controller</code>.</li>\n</ol>\n"},{"owner":{"reputation":678,"user_id":5167492,"user_type":"registered","accept_rate":81,"profile_image":"https://graph.facebook.com/426050827586525/picture?type=large","display_name":"Quan Nguyen","link":"https://stackoverflow.com/users/5167492/quan-nguyen"},"is_accepted":false,"score":15,"last_activity_date":1466426342,"last_edit_date":1466426342,"creation_date":1466415023,"answer_id":37918997,"question_id":6827752,"body":"<p>In Spring 4, latest version:</p>\n\n<blockquote>\n  <p>The @Repository annotation is a marker for any class that fulfills the\n  role or stereotype of a repository (also known as Data Access Object\n  or DAO). Among the uses of this marker is the automatic translation of\n  exceptions as described in Section 20.2.2, “Exception translation”.</p>\n  \n  <p>Spring provides further stereotype annotations: @Component, @Service,\n  and @Controller. @Component is a generic stereotype for any\n  Spring-managed component. @Repository, @Service, and @Controller are\n  specializations of @Component for more specific use cases, for\n  example, in the persistence, service, and presentation layers,\n  respectively. Therefore, you can annotate your component classes with\n  @Component, but by annotating them with @Repository, @Service, or\n  @Controller instead, your classes are more properly suited for\n  processing by tools or associating with aspects. For example, these\n  stereotype annotations make ideal targets for pointcuts. It is also\n  possible that @Repository, @Service, and @Controller may carry\n  additional semantics in future releases of the Spring Framework. Thus,\n  if you are choosing between using @Component or @Service for your\n  service layer, @Service is clearly the better choice. Similarly, as\n  stated above, @Repository is already supported as a marker for\n  automatic exception translation in your persistence layer.</p>\n</blockquote>\n"},{"owner":{"reputation":26057,"user_id":2815219,"user_type":"registered","profile_image":"https://www.gravatar.com/avatar/d10432298a6eacf6be2f263d8fc3776b?s=256&d=identicon&r=PG","display_name":"Raman Sahasi","link":"https://stackoverflow.com/users/2815219/raman-sahasi"},"is_accepted":false,"score":907,"last_activity_date":1558599219,"last_edit_date":1558599219,"creation_date":1469342603,"answer_id":38549461,"question_id":6827752,"body":"<p>As many of the answers already state what these annotations are used for, we'll here focus on some minor differences among them.  </p>\n\n<blockquote>\n  <p>First the <strong>Similarity</strong>   </p>\n  \n  <p>First point worth highlighting again is that <strong>with respect to scan-auto-detection and dependency injection for BeanDefinition</strong> all these annotations (viz., @Component, @Service,\n  @Repository, @Controller) are the same. <strong>We can use one in place\n  of another and can still get our way around.</strong></p>\n</blockquote>\n\n<hr>\n\n<h2>Differences between @Component, @Repository, @Controller and @Service</h2>\n\n<blockquote>\n  <p><strong>@Component</strong></p>\n</blockquote>\n\n<p>This is a general-purpose stereotype annotation indicating that the class is a spring component.</p>\n\n<p><strong><em>What’s special about @Component</em></strong><br>\n<code>&lt;context:component-scan&gt;</code> only scans <code>@Component</code> and does not look for <code>@Controller</code>, <code>@Service</code> and <code>@Repository</code> in general. They are scanned because they themselves are annotated with <code>@Component</code>.</p>\n\n<p>Just take a look at <code>@Controller</code>, <code>@Service</code> and <code>@Repository</code> annotation definitions:</p>\n\n<pre><code>@Component\npublic @interface Service {\n    ….\n}\n</code></pre>\n\n<p> </p>\n\n<pre><code>@Component\npublic @interface Repository {\n    ….\n}\n</code></pre>\n\n<p> </p>\n\n<pre><code>@Component\npublic @interface Controller {\n    …\n}\n</code></pre>\n\n<p>Thus, it’s not wrong to say that <code>@Controller</code>, <code>@Service</code> and <code>@Repository</code> are special types of <code>@Component</code> annotation. <code>&lt;context:component-scan&gt;</code> picks them up and registers their following classes as beans, just as if they were annotated with <code>@Component</code>.</p>\n\n<p>Special type annotations are also scanned, because they themselves are annotated with <code>@Component</code> annotation, which means they are also <code>@Component</code>s. If we define our own custom annotation and annotate it with <code>@Component</code>, it will also get scanned with <code>&lt;context:component-scan&gt;</code></p>\n\n<hr>\n\n<blockquote>\n  <p><strong>@Repository</strong></p>\n</blockquote>\n\n<p>This is to indicate that the class defines a data repository.</p>\n\n<p><strong><em>What’s special about @Repository?</em></strong>  </p>\n\n<p>In addition to pointing out, that this is an <em>Annotation based Configuration</em>, <code>@Repository</code>’s job is to catch platform specific exceptions and re-throw them as one of Spring’s unified unchecked exception. For this, we’re provided with <code>PersistenceExceptionTranslationPostProcessor</code>, that we are required to add in our Spring’s application context like this:</p>\n\n<pre><code>&lt;bean class=\"org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessor\"/&gt;\n</code></pre>\n\n<p>This bean post processor adds an advisor to any bean that’s annotated with <code>@Repository</code> so that any platform-specific exceptions are caught and then re-thrown as one of Spring’s unchecked data access exceptions.</p>\n\n<hr>\n\n<blockquote>\n  <p><strong>@Controller</strong></p>\n</blockquote>\n\n<p>The <code>@Controller</code> annotation indicates that a particular class serves the role of a controller. The <code>@Controller</code> annotation acts as a stereotype for the annotated class, indicating its role.</p>\n\n<p><strong><em>What’s special about @Controller?</em></strong>  </p>\n\n<p>We cannot switch this annotation with any other like <code>@Service</code> or <code>@Repository</code>, even though they look same. \nThe dispatcher scans the classes annotated with <code>@Controller</code> and detects methods annotated with <code>@RequestMapping</code> annotations within them. We can use <code>@RequestMapping</code> on/in only those methods whose classes are annotated with <code>@Controller</code> and it will <strong>NOT</strong> work with <code>@Component</code>, <code>@Service</code>, <code>@Repository</code> etc...</p>\n\n<p><sub><em>Note: If a class is already registered as a bean through any alternate method, like through <code>@Bean</code> or through <code>@Component</code>, <code>@Service</code> etc... annotations, then <code>@RequestMapping</code> can be picked if the class is also annotated with <code>@RequestMapping</code> annotation. But that's a different scenario.</em></sub></p>\n\n<hr>\n\n<blockquote>\n  <p><strong>@Service</strong></p>\n</blockquote>\n\n<p><code>@Service</code> beans hold the business logic and call methods in the repository layer. </p>\n\n<p><strong><em>What’s special about @Service?</em></strong>  </p>\n\n<p>Apart from the fact that it's used to indicate, that it's holding the business logic, there’s nothing else noticeable in this annotation; but who knows, Spring may add some additional exceptional in future.</p>\n\n<hr>\n\n<blockquote>\n  <p><strong><em>What else?</em></strong></p>\n</blockquote>\n\n<p>Similar to above, in the future Spring may add special functionalities for <code>@Service</code>, <code>@Controller</code> and <code>@Repository</code> based on their layering conventions. Hence, it's always a good idea to respect the convention and use it in line with layers.</p>\n"},{"owner":{"reputation":543,"user_id":3912516,"user_type":"registered","accept_rate":60,"profile_image":"https://i.stack.imgur.com/0WD1E.png?s=256&g=1","display_name":"Amol Dixit","link":"https://stackoverflow.com/users/3912516/amol-dixit"},"is_accepted":false,"score":13,"last_activity_date":1499448363,"last_edit_date":1499448363,"creation_date":1482311530,"answer_id":41258961,"question_id":6827752,"body":"<p><code>@Component</code> is the top level generic annotation which makes the annotated bean to be scanned and available in the DI container</p>\n\n<p><code>@Repository</code> is specialized annotation and it brings the feature of converting all the unchecked exceptions from the DAO classes</p>\n\n<p><code>@Service</code> is specialized annotation. it do not bring any new feature as of now but it clarifies the intent of the bean</p>\n\n<p>@Controller is specialized annotation which makes the bean MVC aware and allows the use of further annotation like <code>@RequestMapping</code> and all such</p>\n\n<p>Here are more <a href=\"http://howtodoinjava.com/spring/spring-core/how-to-use-spring-component-repository-service-and-controller-annotations/\" rel=\"noreferrer\">details</a></p>\n"},{"owner":{"reputation":1689,"user_id":992706,"user_type":"registered","accept_rate":63,"profile_image":"https://www.gravatar.com/avatar/c4157893cac7f2758cdce7f48120828e?s=256&d=identicon&r=PG","display_name":"Bharath","link":"https://stackoverflow.com/users/992706/bharath"},"is_accepted":false,"score":11,"last_activity_date":1482913139,"creation_date":1482913139,"answer_id":41358034,"question_id":6827752,"body":"<p>A <code>@Service</code> to quote spring documentation,</p>\n\n<blockquote>\n  <p>Indicates that an annotated class is a \"Service\", <strong>originally defined\n  by Domain-Driven Design (Evans, 2003) as \"an operation offered as an\n  interface that stands alone in the model, with no encapsulated state.\"</strong>\n  May also indicate that a class is a \"Business Service Facade\" (in the\n  Core J2EE patterns sense), or something similar. This annotation is a\n  general-purpose stereotype and individual teams may narrow their\n  semantics and use as appropriate.</p>\n</blockquote>\n\n<p>If you look at domain driven design by eric evans, </p>\n\n<blockquote>\n  <p>A SERVICE is an operation offered as an interface that stands alone in\n  the model, without encapsulating state, as ENTITIES and VALUE OBJECTS\n  do. SERVICES are a common pattern in technical frameworks, but they\n  can also apply in the domain layer. The name service emphasizes the\n  relationship with other objects. Unlike ENTITIES and VALUE OBJECTS, it\n  is defined purely in terms of what it can do for a client. A SERVICE\n  tends to be named for an activity, rather than an entity—a verb rather\n  than a noun. A SERVICE can still have an abstract, intentional\n  definition; it just has a different flavor than the definition of an\n  object. A SERVICE should still have a defined responsibility, and that\n  responsibility and the interface fulfilling it should be defined as\n  part of the domain model. Operation names should come from the\n  UBIQUITOUS LANGUAGE or be introduced into it. Parameters and results\n  should be domain objects. SERVICES should be used judiciously and not\n  allowed to strip the ENTITIES and VALUE OBJECTS of all their behavior.\n  But when an operation is actually an important domain concept, a\n  SERVICE forms a natural part of a MODEL-DRIVEN DESIGN. Declared in the\n  model as a SERVICE, rather than as a phony object that doesn't\n  actually represent anything, the standalone operation will not mislead\n  anyone. </p>\n</blockquote>\n\n<p>and a <code>Repository</code> as per Eric Evans,</p>\n\n<blockquote>\n  <p>A REPOSITORY represents all objects of a certain type as a conceptual\n  set (usually emulated). It acts like a collection, except with more\n  elaborate querying capability. Objects of the appropriate type are\n  added and removed, and the machinery behind the REPOSITORY inserts\n  them or deletes them from the database. This definition gathers a\n  cohesive set of responsibilities for providing access to the roots of\n  AGGREGATES from early life cycle through the end.</p>\n</blockquote>\n"},{"owner":{"reputation":1535,"user_id":5536695,"user_type":"registered","accept_rate":40,"profile_image":"https://www.gravatar.com/avatar/462842ef9c0d576967057065b4b962d6?s=256&d=identicon&r=PG&f=1","display_name":"YogendraR","link":"https://stackoverflow.com/users/5536695/yogendrar"},"is_accepted":false,"score":52,"last_activity_date":1561010431,"last_edit_date":1561010431,"creation_date":1501150832,"answer_id":45347943,"question_id":6827752,"body":"<p>Technically <code>@Controller</code>, <code>@Service</code>, <code>@Repository</code> are all same. All of them extends <code>@Component</code>.</p>\n\n<p>From the Spring source code:</p>\n\n<p>Indicates that an annotated class is a \"component\". Such classes are considered as candidates for auto-detection when using annotation-based configuration and classpath scanning.</p>\n\n<p>We can directly use <code>@Component</code> for each and every bean, but for better understanding and maintainability of a large application, we use <code>@Controller</code>, <code>@Service</code>, <code>@Repository</code>.</p>\n\n<p>Purpose of each annotation:</p>\n\n<ol>\n<li><code>@Controller</code> -> Classes annotated with this, are intended to receive a request from the client side. The first request comes to the Dispatcher Servlet, from where it passes the request to the particular controller using the value of <code>@RequestMapping</code> annotation.</li>\n<li><code>@Service</code> -> Classes annotated with this, are intended to manipulate data, that we receive from the client or fetch from the database. All the manipulation with data should be done in this layer.</li>\n<li><code>@Repository</code> -> Classes annotated with this, are intended to connect with database. It can also be considered as DAO(Data Access Object) layer. This layer should be restricted to CRUD (create, retrieve, update, delete) operations only.\nIf any manipulation is required, data should be sent be send back to @Service layer.</li>\n</ol>\n\n<p>If we interchange their place(use <code>@Repository</code> in place of <code>@Controller</code>), our application will work fine.</p>\n\n<p>The main purpose of using three different <code>@annotations</code> is to provide better Modularity to the Enterprise application.</p>\n"},{"owner":{"reputation":1608,"user_id":4334162,"user_type":"registered","profile_image":"https://lh3.googleusercontent.com/-5tBwtP88Td8/AAAAAAAAAAI/AAAAAAAAAL4/Kljmv21tq9E/photo.jpg?sz=256","display_name":"Arun Raaj","link":"https://stackoverflow.com/users/4334162/arun-raaj"},"is_accepted":false,"score":20,"last_activity_date":1576472757,"last_edit_date":1576472757,"creation_date":1510234330,"answer_id":47203202,"question_id":6827752,"body":"<p><strong>@Component</strong>: you annotate a class <code>@Component</code>, it tells hibernate that it is a Bean.</p>\n\n<p><strong>@Repository</strong>: you annotate a class <code>@Repository</code>, it tells hibernate it is a DAO class and treat it as DAO class. Means it makes the unchecked exceptions (thrown from DAO methods) eligible for translation into Spring <code>DataAccessException</code>.</p>\n\n<p><strong>@Service</strong>: This tells hibernate it is a Service class where you will have <code>@Transactional</code> etc Service layer annotations so hibernate treats it as a Service component.</p>\n\n<p>Plus <code>@Service</code> is advance of <code>@Component</code>. Assume the bean class name is <code>CustomerService</code>, since you did not choose XML bean configuration way so you annotated the bean with <code>@Component</code> to indicate it as a Bean. So while getting the bean object <code>CustomerService cust = (CustomerService)context.getBean(\"customerService\");</code> By default, Spring will lower case the first character of the component – from ‘CustomerService’ to ‘customerService’. And you can retrieve this component with name ‘customerService’.\nBut if you use <code>@Service</code> annotation for the bean class you can provide a specific bean name by </p>\n\n<pre><code>@Service(\"AAA\")\npublic class CustomerService{\n</code></pre>\n\n<p>and you can get the bean object by </p>\n\n<pre><code>CustomerService cust = (CustomerService)context.getBean(\"AAA\");\n</code></pre>\n"},{"owner":{"reputation":1072,"user_id":8450064,"user_type":"registered","profile_image":"https://lh4.googleusercontent.com/-sUFHZf-glew/AAAAAAAAAAI/AAAAAAAAAJU/DskFo5Z8xZ8/photo.jpg?sz=256","display_name":"Anil Nivargi","link":"https://stackoverflow.com/users/8450064/anil-nivargi"},"is_accepted":false,"score":21,"last_activity_date":1514878950,"last_edit_date":1592644375,"creation_date":1511376123,"answer_id":47441820,"question_id":6827752,"body":"<p>Annotate other components with @Component, for example REST Resource classes.</p>\n<pre><code>@Component\npublic class AdressComp{\n    .......\n    ...//some code here    \n}\n</code></pre>\n<p>@Component is a generic stereotype for any Spring managed component.</p>\n<p>@Controller, @Service and @Repository are Specializations of @Component for specific use cases.</p>\n<h3>@Component in Spring</h3>\n<p><a href=\"https://i.stack.imgur.com/FFIdh.png\" rel=\"noreferrer\"><img src=\"https://i.stack.imgur.com/FFIdh.png\" alt=\"&quot;Component Specialization&quot;\" /></a></p>\n"},{"owner":{"reputation":5851,"user_id":1194067,"user_type":"registered","accept_rate":73,"profile_image":"https://i.stack.imgur.com/ODFpP.jpg?s=256&g=1","display_name":"Jeevan Patil","link":"https://stackoverflow.com/users/1194067/jeevan-patil"},"is_accepted":false,"score":6,"last_activity_date":1521615785,"creation_date":1521615785,"answer_id":49400133,"question_id":6827752,"body":"<p><strong>Explanation of stereotypes :</strong> </p>\n\n<ul>\n<li><code>@Service</code> - Annotate all your service classes with @Service. This layer knows the unit of work. All your business logic will be in Service classes. Generally methods of service layer are covered under transaction. You can make multiple DAO calls from service method, if one transaction fails all transactions should rollback.</li>\n<li><code>@Repository</code> - Annotate all your DAO classes with @Repository. All your database access logic should be in DAO classes.</li>\n<li><code>@Component</code> - Annotate your other components (for example REST resource classes) with component stereotype.</li>\n<li><code>@Autowired</code> - Let Spring auto-wire other beans into your classes using @Autowired annotation. </li>\n</ul>\n\n<p><code>@Component</code> is a generic stereotype for any Spring-managed component. <code>@Repository</code>, <code>@Service</code>, and <code>@Controller</code> are specializations of <code>@Component</code> for more specific use cases, for example, in the persistence, service, and presentation layers, respectively. </p>\n\n<p>Originally answered <a href=\"https://stackoverflow.com/questions/16051656/advantages-of-using-spring-stereotypes/16105106#16105106\">here</a>.</p>\n"},{"owner":{"reputation":537,"user_id":9112160,"user_type":"registered","profile_image":"https://www.gravatar.com/avatar/02d01bb0489ca0dcfb3cf4d3a0a5d505?s=256&d=identicon&r=PG","display_name":"UHDante","link":"https://stackoverflow.com/users/9112160/uhdante"},"is_accepted":false,"score":3,"last_activity_date":1588880493,"last_edit_date":1588880493,"creation_date":1529539817,"answer_id":50958679,"question_id":6827752,"body":"<p><code>@Component</code>, <code>@ Repository</code>, <code>@ Service</code>, <code>@Controller</code>:</p>\n\n<p><code>@Component</code> is a generic stereotype for the components managed by Spring <code>@Repository</code>, <code>@Service</code>, and <code>@Controller</code> are <code>@Component</code> specializations for more specific uses:</p>\n\n<ul>\n<li><code>@Repository</code> for persistence</li>\n<li><code>@Service</code> for services and transactions</li>\n<li><code>@Controller</code> for MVC controllers</li>\n</ul>\n\n<p>Why use <code>@Repository</code>, <code>@Service</code>, <code>@Controller</code> over <code>@Component</code>?\nWe can mark our component classes with @Component, but if instead we use the alternative that adapts to the expected functionality. Our classes are better suited to the functionality expected in each particular case.</p>\n\n<p>A class annotated with <code>@Repository</code> has a better translation and readable error handling with org.springframework.dao.DataAccessException. Ideal for implementing components that access data (DataAccessObject or DAO).</p>\n\n<p>An annotated class with <code>@Controller</code> plays a controller role in a Spring Web MVC application</p>\n\n<p>An annotated class with <code>@Service</code> plays a role in business logic services, example Facade pattern for DAO Manager (Facade) and transaction handling</p>\n"},{"owner":{"reputation":1317,"user_id":3950690,"user_type":"registered","profile_image":"https://i.stack.imgur.com/pGASh.png?s=256&g=1","display_name":"Brajesh","link":"https://stackoverflow.com/users/3950690/brajesh"},"is_accepted":false,"score":3,"last_activity_date":1530817917,"creation_date":1530817917,"answer_id":51198370,"question_id":6827752,"body":"<p>In spring framework provides some special type of annotations,called stereotype annotations.\nThese are following:-</p>\n\n<pre><code>@RestController- Declare at controller level.\n@Controller – Declare at controller level.\n@Component – Declare at Bean/entity level.\n@Repository – Declare at DAO level.\n@Service – Declare at BO level.\n</code></pre>\n\n<p>above declared annotations are special because when we add <code>&lt;context:component-scan&gt;</code> into xxx-servlet.xml file ,spring will automatically create the object of those classes which are annotated with above annotation during context creation/loading phase.</p>\n"},{"owner":{"reputation":115,"user_id":9609300,"user_type":"registered","profile_image":"https://www.gravatar.com/avatar/87c141f7644c790e1ec31107d0d89f49?s=256&d=identicon&r=PG&f=1","display_name":"siddartha kamble","link":"https://stackoverflow.com/users/9609300/siddartha-kamble"},"is_accepted":false,"score":-15,"last_activity_date":1575042303,"last_edit_date":1575042303,"creation_date":1535568380,"answer_id":52084238,"question_id":6827752,"body":"<pre><code>@Component\n@Controller\n@Repository\n@Service\n@RestController\n</code></pre>\n\n<p>These are all StereoType annotations.this are usefull for the making our classes as spring beans in ioc container, </p>\n"},{"owner":{"reputation":181,"user_id":8411174,"user_type":"registered","profile_image":"https://graph.facebook.com/1341521072627028/picture?type=large","display_name":"Maria Pomazkina-Karpikova","link":"https://stackoverflow.com/users/8411174/maria-pomazkina-karpikova"},"is_accepted":false,"score":9,"last_activity_date":1538533964,"creation_date":1538533964,"answer_id":52618927,"question_id":6827752,"body":"<p><em>Repository</em> and <em>Service</em> are children of <em>Component</em> annotation. So, all of them are <em>Component</em>. <em>Repository</em> and <em>Service</em> just expand it. \nHow exactly?\n<em>Service</em> has only ideological difference: we use it for services. <em>Repository</em> has particular exception handler.</p>\n"},{"owner":{"reputation":898,"user_id":4177869,"user_type":"registered","accept_rate":50,"profile_image":"https://i.stack.imgur.com/CilJt.jpg?s=256&g=1","display_name":"Mohamed Sweelam","link":"https://stackoverflow.com/users/4177869/mohamed-sweelam"},"is_accepted":false,"score":1,"last_activity_date":1556655712,"creation_date":1556655712,"answer_id":55928163,"question_id":6827752,"body":"<p>In order to simplify this illustration, let us consider technicality by use case, These annotations are used to be injected and as I said literally \"<em>Used to be injected</em>\" , that mean, if you know how to use <strong>Dependency Injection \"DI\"</strong>  and you should, then you will always look for these annotations, and by annotating the classes with these <strong>Stereo Types</strong>, you are informing the <em>DI</em> container to scan them to be ready for Injection on other places, this is the practical target.</p>\n\n<p>Now lets move to each one; first <strong>@Service</strong>, If you are building some logic for specific business case you need to separate that in a place which will contain your business logic, this service is normal Class or you can use it as interface if you want , and it is written like this </p>\n\n<pre class=\"lang-java prettyprint-override\"><code>@Service\npublic class Doer {\n   // Your logic \n}\n\n// To use it in another class, suppose in Controller \n@Controller\npublic class XController {\n // You have to inject it like this \n @Autowired \n private Doer doer;\n}\n</code></pre>\n\n<p>All are the same way when you inject them, <strong>@Repository</strong> it's an interface which apply the implementation for the Repository Pattern <a href=\"https://stackoverflow.com/questions/5166888/repository-design-pattern\">Repository design pattern</a>, generally it's used when you are dealing with some data store or database, and you will find that, it contains multiple ready implementation for you to handle database operations; it can be  <em>CrudRepository</em>, <em>JpaRepository</em> etc.</p>\n\n<pre class=\"lang-java prettyprint-override\"><code>// For example\npublic interface DoerRepository implements JpaRepository&lt;Long, XEntity&gt; {}\n</code></pre>\n\n<p>Finally the <strong>@Component</strong>, this is the generic form for registered beans in Spring, that's spring is always looking for bean marked with @Component to be registered, then both @Service and @Repository are special cases of @Component, however the common use case for component is when you're making something purely technical not for covering direct business case! like formatting dates or handing special request serialization mechanism and so on.</p>\n"},{"owner":{"reputation":9986,"user_id":10961238,"user_type":"registered","profile_image":"https://lh6.googleusercontent.com/-1Tz8-GsqpuU/AAAAAAAAAAI/AAAAAAAAAaQ/xTj_-pz1PhI/photo.jpg?sz=256","display_name":"Romil Patel","link":"https://stackoverflow.com/users/10961238/romil-patel"},"is_accepted":false,"score":12,"last_activity_date":1562224923,"creation_date":1562224923,"answer_id":56882597,"question_id":6827752,"body":"<p>Good enough answers are here to explain the whats-the-difference-between-component-repository-service-annotations. I would like to share the difference between <code>@Controller &amp; @RestController</code></p>\n\n<h1><strong><code>@Controller</code></strong> vs <strong><code>RestController</code></strong></h1>\n\n<h2><strong><code>@RestController</code></strong>:</h2>\n\n<p><a href=\"https://i.stack.imgur.com/U9mP2.png\" rel=\"noreferrer\"><img src=\"https://i.stack.imgur.com/U9mP2.png\" alt=\"enter image description here\"></a></p>\n\n<ul>\n<li>This annotation is a specialized version of <code>@Controller</code> which adds\n<code>@Controller</code> and <code>@ResponseBody</code> annotation automatically. so we do not have to add <code>@ResponseBody</code> to our mapping methods. That means\n<code>@ResponseBody</code> is default active.</li>\n<li>If you use <code>@RestController</code> you cannot return a view (By using\n<code>Viewresolver</code> in Spring/Spring-Boot)</li>\n<li><code>@RestController</code> also converts the response to <code>JSON/XML automatically</code> as <code>@ResponseBody</code> makes the returned objects to something that could be in the body, <code>e.g. JSON or XML</code> </li>\n</ul>\n\n<hr>\n\n<h2><strong><code>@Controller</code></strong></h2>\n\n<p><a href=\"https://i.stack.imgur.com/BKR7s.png\" rel=\"noreferrer\"><img src=\"https://i.stack.imgur.com/BKR7s.png\" alt=\"enter image description here\"></a></p>\n\n<ul>\n<li><code>@Controller</code> is used to mark classes as Spring MVC Controller. This\nannotation is just a specialized version of <code>@Component</code> and it\nallows the controller classes to be auto-detected based on classpath\nscanning.</li>\n<li><code>@Controller</code> you can return a view in Spring web MVC.</li>\n</ul>\n\n<p><a href=\"https://www.genuitec.com/spring-frameworkrestcontroller-vs-controller/\" rel=\"noreferrer\">More Detailed View</a></p>\n"},{"owner":{"reputation":2153,"user_id":5256337,"user_type":"registered","profile_image":"https://i.stack.imgur.com/d3GFu.jpg?s=256&g=1","display_name":"Lova Chittumuri","link":"https://stackoverflow.com/users/5256337/lova-chittumuri"},"is_accepted":false,"score":5,"last_activity_date":1572475880,"last_edit_date":1572475880,"creation_date":1565076350,"answer_id":57370920,"question_id":6827752,"body":"<p><strong>Difference between @Component, @Repository, @Controller &amp; @Service annotations</strong></p>\n\n<blockquote>\n  <p>@Component – generic and can be used across application.<br> @Service\n  – annotate classes at service layer level.<br> @Controller – annotate\n  classes at presentation layers level, mainly used in Spring MVC.<br>\n  @Repository – annotate classes at persistence layer, which will act as\n  database repository.</p>\n</blockquote>\n\n<p><code>@Controller</code> = @Component ( Internal Annotation ) + Presentation layer Features <br>\n<code>@Service</code> = @Component ( Internal Annotation ) + Service layer Features<br>\n<code>@Component</code> = Actual Components ( Beans )<br>\n<code>@Repository</code> = @Component ( Internal Annotation ) + Data Layer Features ( use for handling the Domain Beans )<br></p>\n"},{"owner":{"reputation":1673,"user_id":10610826,"user_type":"registered","profile_image":"https://i.stack.imgur.com/lhqqt.png?s=256&g=1","display_name":"Mykhailo Moskura","link":"https://stackoverflow.com/users/10610826/mykhailo-moskura"},"is_accepted":false,"score":5,"last_activity_date":1587257408,"creation_date":1587257408,"answer_id":61298214,"question_id":6827752,"body":"<p><strong>@Component</strong> acts as @Bean annotation in configuration class , register bean in spring context. Also it is parent for @Service, @Repository and @Controller annotation.</p>\n\n<p><strong>@Service</strong>, extends @Component annotation and has only naming difference.</p>\n\n<p><strong>@Repository</strong> - extends @Component annotation and translate all database exceptions into \n<a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/dao/DataAccessException.html\" rel=\"noreferrer\">DataAccessException</a>.</p>\n\n<p><strong>@Controller</strong> - acts as controller in MVC pattern. The dispatcher will scan such annotated classes for mapped methods, detecting @RequestMapping annotations.</p>\n"},{"owner":{"reputation":14046,"user_id":2051454,"user_type":"registered","accept_rate":60,"profile_image":"https://i.stack.imgur.com/sZBFW.jpg?s=256&g=1","display_name":"Software Engineer","link":"https://stackoverflow.com/users/2051454/software-engineer"},"is_accepted":false,"score":15,"last_activity_date":1616614947,"last_edit_date":1616614947,"creation_date":1588944349,"answer_id":61680242,"question_id":6827752,"body":"<p>The answers presented here are partially technically correct, but even though the response list is long and this will be at the bottom I thought it was worth putting an actually correct response in here too, just in case somebody stumbles upon it and learns something valuable from it. It's not that the rest of the answers are completely wrong, it's just that they aren't right. And, to stop the hordes of trolls, yes, I know that technically these annotations are effectively the same thing right now and mostly interchangeable even unto spring 5. Now, for the right answer:</p>\n<p>These three annotations are completely different things and are not interchangeable. You can tell that because there are three of them rather than just one. They are not intended to be interchangeable, they're just implemented that way out of elegance and convenience.</p>\n<p>Modern programming is invention, art, technique, and communication, in varying proportions. The communication bit is usually very important because code is usually read much more often than its written. As a programmer you're not only trying to solve the technical problem, you're also trying to communicate your intent to future programmers who read your code. These programmers may not share your native language, nor your social environment, and it is possible that they may be reading your code 50-years in the future (it's not as unlikely as you may think). It's difficult to communicate effectively that far into the future. Therefore, it is vital that we use the clearest, most efficient, correct, and communicative language available to us. That we chose our words carefully to have maximum impact and to be as clear as possible as to our intent.</p>\n<p>For example, it is vital that <code>@Repository</code> is used when we're writing a repository, rather than <code>@Component</code>. The latter is a very poor choice of annotation for a repository because it does not indicate that we're looking at a repository. We can assume that a repository is also a spring-bean, but not that a component is a repository. With <code>@Repository</code> we are being clear and specific in our language. We are stating clearly that this is a repository. With <code>@Component</code> we are leaving it to the reader to decide what type of component they are reading, and they will have to read the whole class (and possibly a tree of subclasses and interfaces) to infer meaning. The class could then possibly be misinterpreted by a reader in the distant future as not being a repository, and we would have been partially responsible for this mistake because we, who knew full well that this is a repository, failed to be specific in our language and communicate effectively our intent.</p>\n<p>I won't go into the other examples, but will state as clearly as I can: these annotations are completely different things and should be used appropriately, as per their intent. <code>@Repository</code> is for storage repositories and no other annotation is correct. <code>@Service</code> is for services and no other annotation is correct. <code>@Component</code> is for components that are neither repositories nor services, and to use either of these in its place would also be incorrect. It might compile, it might even run and pass your tests, but it would be wrong and I would think less of you (professionally) if you were to do this.</p>\n<p>There are examples of this throughout spring (and programming in general). You must not use <code>@Controller</code> when writing a REST API, because <code>@RestController</code> is available. You must not use <code>@RequestMapping</code> when <code>@GetMapping</code> is a valid alternative. Etc. Etc. Etc. You <em>must</em> chose the most specific exact and correct language you can to communicate your intent to your readers, otherwise, you are introducing risks into your system, and risk has a cost.</p>\n<p>Finally, I'd like to bring up a point of order concerning Object-Oriented systems. One of the fundamental rules is that implementations can vary but interfaces shouldn't. Assuming that these annotations are the same thing is a very slippery slope and completely against OO. Although they may be implemented in an interchangeable way now, there is no guarantee that they will be in the future. Further, even within the same team, an engineer may decide to hang some behaviour off one or more of these annotations using aspects, or a platform engineer may choose to replace the implementation of one of these for operational reasons. You just don't know, nor should you -- in OO you rely on the interface, not the implementation.</p>\n"}],"owner":{"reputation":23317,"user_id":863084,"user_type":"unregistered","profile_image":"https://www.gravatar.com/avatar/be273143043ed0ff5b55406ac70ff41e?s=256&d=identicon&r=PG","display_name":"Colin McCree","link":"https://stackoverflow.com/users/863084/colin-mccree"},"is_answered":true,"view_count":1002646,"protected_date":1452629449,"answer_count":29,"score":2326,"last_activity_date":1624638717,"creation_date":1311671446,"last_edit_date":1581945021,"question_id":6827752,"link":"https://stackoverflow.com/questions/6827752/whats-the-difference-between-component-repository-service-annotations-in","title":"What&#39;s the difference between @Component, @Repository &amp; @Service annotations in Spring?","body":"<p>Can <a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Component.html\" rel=\"noreferrer\"><code>@Component</code></a>, <a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Repository.html\" rel=\"noreferrer\"><code>@Repository</code></a> and <a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Service.html\" rel=\"noreferrer\"><code>@Service</code></a> annotations be used interchangeably in Spring or do they provide any particular functionality besides acting as a notation device?</p>\n\n<p>In other words, if I have a Service class and I change the annotation from <code>@Service</code> to <code>@Component</code>, will it still behave the same way? </p>\n\n<p>Or does the annotation also influence the behavior and functionality of the class?</p>\n"}],"has_more":false,"quota_max":300,"quota_remaining":232}